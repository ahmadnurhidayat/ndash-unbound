// Utility functions for Unbound DNS management

const { exec } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const config = require('../config');

/**
 * Read Unbound configuration file
 * @param {string} confPath - Path to config file
 * @returns {Promise<string>} Config file content
 */
async function readConfigFile(confPath) {
    try {
        return await fs.readFile(confPath, 'utf8');
    } catch (error) {
        throw new Error(`Failed to read config file: ${error.message}`);
    }
}

/**
 * Write to Unbound configuration file
 * @param {string} confPath - Path to config file
 * @param {string} content - Config file content
 */
async function writeConfigFile(confPath, content) {
    try {
        await fs.ensureDir(path.dirname(confPath));
        await fs.writeFile(confPath, content, 'utf8');
    } catch (error) {
        throw new Error(`Failed to write config file: ${error.message}`);
    }
}

/**
 * Execute Unbound reload command
 * @returns {Promise<string>} Command output
 */
function reloadUnbound() {
    return new Promise((resolve, reject) => {
        exec(config.unbound.reloadCommand, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Unbound reload failed: ${stderr || error.message}`));
            } else {
                resolve(stdout);
            }
        });
    });
}

/**
 * Check Unbound configuration syntax
 * @returns {Promise<boolean>} True if valid
 */
function checkConfigSyntax() {
    return new Promise((resolve, reject) => {
        exec(config.unbound.checkCommand, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Config syntax error: ${stderr || error.message}`));
            } else {
                resolve(true);
            }
        });
    });
}

/**
 * Get Unbound status
 * @returns {Promise<Object>} Status information
 */
function getUnboundStatus() {
    return new Promise((resolve, reject) => {
        exec(`${config.unbound.controlCommand} status`, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Failed to get status: ${stderr || error.message}`));
            } else {
                resolve(parseStatusOutput(stdout));
            }
        });
    });
}

/**
 * Parse unbound-control status output
 * @param {string} output - Status output
 * @returns {Object} Parsed status
 */
function parseStatusOutput(output) {
    const status = {
        running: output.includes('is running'),
        uptime: null,
        queries: null
    };
    
    const lines = output.split('\n');
    lines.forEach(line => {
        if (line.includes('uptime:')) {
            status.uptime = line.split(':')[1].trim();
        }
        if (line.includes('queries:')) {
            status.queries = parseInt(line.split(':')[1].trim());
        }
    });
    
    return status;
}

/**
 * Generate local-zone configuration for a zone
 * @param {Object} zone - Zone object
 * @param {Array} records - Array of record objects
 * @returns {string} Unbound local-zone configuration
 */
function generateLocalZoneConfig(zone, records) {
    let content = `# Local zone configuration for ${zone.name}\n`;
    content += `# Generated by NDash on ${new Date().toISOString()}\n\n`;
    
    // Define the local zone
    content += `server:\n`;
    content += `    # Zone: ${zone.name}\n`;
    content += `    local-zone: "${zone.name}" static\n\n`;
    
    // Add local-data entries for each record
    records.forEach(record => {
        const fqdn = record.name === '@' || record.name === zone.name 
            ? zone.name 
            : record.name.endsWith('.') 
                ? record.name 
                : `${record.name}.${zone.name}`;
        
        const ttl = record.ttl || config.dns.defaultTTL;
        
        if (record.type === 'MX') {
            const priority = record.priority || 10;
            content += `    local-data: "${fqdn}. ${ttl} IN ${record.type} ${priority} ${record.value}"\n`;
        } else if (record.type === 'SRV') {
            const priority = record.priority || 10;
            const weight = record.weight || 0;
            const port = record.port || 0;
            content += `    local-data: "${fqdn}. ${ttl} IN ${record.type} ${priority} ${weight} ${port} ${record.value}"\n`;
        } else if (record.type === 'TXT') {
            // Escape quotes in TXT records
            const value = record.value.includes('"') ? record.value : `"${record.value}"`;
            content += `    local-data: "${fqdn}. ${ttl} IN ${record.type} ${value}"\n`;
        } else {
            content += `    local-data: "${fqdn}. ${ttl} IN ${record.type} ${record.value}"\n`;
        }
    });
    
    content += '\n';
    return content;
}

/**
 * Parse Unbound local-zone configuration
 * @param {string} content - Config file content
 * @returns {Object} Parsed zones and records
 */
function parseLocalZoneConfig(content) {
    const zones = {};
    const lines = content.split('\n');
    
    let currentZone = null;
    
    lines.forEach(line => {
        line = line.trim();
        
        // Skip comments and empty lines
        if (line.startsWith('#') || line === '') return;
        
        // Parse local-zone directive
        const zoneMatch = line.match(/local-zone:\s+"([^"]+)"\s+(\w+)/);
        if (zoneMatch) {
            currentZone = zoneMatch[1];
            zones[currentZone] = {
                name: currentZone,
                type: zoneMatch[2],
                records: []
            };
            return;
        }
        
        // Parse local-data directive
        const dataMatch = line.match(/local-data:\s+"([^"]+)\.?\s+(\d+)?\s*IN\s+(\w+)\s+(.+)"/);
        if (dataMatch && currentZone) {
            const [, name, ttl, type, value] = dataMatch;
            
            let recordValue = value.trim();
            let priority = null;
            let weight = null;
            let port = null;
            
            // Parse MX priority
            if (type === 'MX') {
                const parts = recordValue.split(/\s+/);
                priority = parseInt(parts[0]);
                recordValue = parts.slice(1).join(' ');
            }
            
            // Parse SRV fields
            if (type === 'SRV') {
                const parts = recordValue.split(/\s+/);
                priority = parseInt(parts[0]);
                weight = parseInt(parts[1]);
                port = parseInt(parts[2]);
                recordValue = parts.slice(3).join(' ');
            }
            
            zones[currentZone].records.push({
                name: name.replace(`.${currentZone}`, '') || '@',
                type: type,
                value: recordValue,
                ttl: ttl ? parseInt(ttl) : config.dns.defaultTTL,
                priority,
                weight,
                port
            });
        }
    });
    
    return zones;
}

/**
 * Generate serial number (YYYYMMDDNN format)
 * @returns {string} Serial number
 */
function generateSerial() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    return `${year}${month}${day}01`;
}

/**
 * Validate IP address
 * @param {string} ip - IP address to validate
 * @returns {boolean} True if valid IPv4
 */
function isValidIPv4(ip) {
    const regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (!regex.test(ip)) return false;
    
    const parts = ip.split('.');
    return parts.every(part => {
        const num = parseInt(part);
        return num >= 0 && num <= 255;
    });
}

/**
 * Validate IPv6 address
 * @param {string} ip - IP address to validate
 * @returns {boolean} True if valid IPv6
 */
function isValidIPv6(ip) {
    const regex = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    return regex.test(ip);
}

/**
 * Validate domain name
 * @param {string} domain - Domain name to validate
 * @returns {boolean} True if valid
 */
function isValidDomain(domain) {
    const regex = /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i;
    return regex.test(domain);
}

/**
 * Flush Unbound cache for a specific zone
 * @param {string} zoneName - Zone name to flush
 * @returns {Promise<string>} Command output
 */
function flushZone(zoneName) {
    return new Promise((resolve, reject) => {
        exec(`${config.unbound.controlCommand} flush_zone ${zoneName}`, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Failed to flush zone: ${stderr || error.message}`));
            } else {
                resolve(stdout);
            }
        });
    });
}

/**
 * Flush all Unbound cache
 * @returns {Promise<string>} Command output
 */
function flushAll() {
    return new Promise((resolve, reject) => {
        exec(`${config.unbound.controlCommand} flush_zone .`, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Failed to flush cache: ${stderr || error.message}`));
            } else {
                resolve(stdout);
            }
        });
    });
}

/**
 * Get Unbound statistics
 * @returns {Promise<Object>} Statistics data
 */
function getStatistics() {
    return new Promise((resolve, reject) => {
        exec(`${config.unbound.controlCommand} stats_noreset`, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Failed to get statistics: ${stderr || error.message}`));
            } else {
                resolve(parseStatsOutput(stdout));
            }
        });
    });
}

/**
 * Parse unbound-control stats output
 * @param {string} output - Stats output
 * @returns {Object} Parsed statistics
 */
function parseStatsOutput(output) {
    const stats = {};
    const lines = output.split('\n');
    
    lines.forEach(line => {
        const parts = line.split('=');
        if (parts.length === 2) {
            const key = parts[0].trim();
            const value = parts[1].trim();
            stats[key] = isNaN(value) ? value : parseFloat(value);
        }
    });
    
    return stats;
}

module.exports = {
    readConfigFile,
    writeConfigFile,
    reloadUnbound,
    checkConfigSyntax,
    getUnboundStatus,
    generateLocalZoneConfig,
    parseLocalZoneConfig,
    generateSerial,
    isValidIPv4,
    isValidIPv6,
    isValidDomain,
    flushZone,
    flushAll,
    getStatistics,
    parseStatsOutput,
    parseStatusOutput
};
